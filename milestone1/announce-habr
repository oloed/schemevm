Я могу писать программы на псевдокоде и превращать их в PHP-код. Или в переносимый Си. Или ещё во что-нибудь. Список будет пополняться.

Часть проекта, которая «превращать в PHP», готова не полностью. Но я пишу статью уже сейчас, чтобы:

<ul>
<li>узнать, кому ещё интересен проект;</li>
<li>спросить у опытных пхпшников, как улучшить мой PHP-код и как померять, что именно тормозит.</li>
</ul>
Пример и технические детали под хаброкатом. <habracut/>

Пример программы:

<code>(<b>display</b> "Hello, world!\n")</code>

Или посложней:

<code>
(<b>define</b> (сделать-писателя что-писать)
&nbsp;&nbsp;(<b>lambda</b> () (<b>display</b> что-писать)))
(<b>define</b> пиши-привет (<b>сделать-писателя</b> "Привет!\n"))
(<b>пиши-привет</b>)</code>

В этом примере функция возвращает функцию. На PHP код выглядел бы так (не работает):

<code><b>function</b> сделать_писателя($что_писать) {
&nbsp;&nbsp;<b>return</b> <b>function</b> () {
&nbsp;&nbsp;&nbsp;&nbsp;<b>print</b> $что_писать;
&nbsp;&nbsp;}
}
$пиши_привет = <b>сделать_писателя</b>("Привет!\n");
$<b>пиши_привет</b>();</code>

На остальные примеры можно посмотреть <a href="http://github.com/olpa/schemevm/tree/milestone1">на github</a> или <a href="http://github.com/downloads/olpa/schemevm/gambit-php-20110208-milestone1.tar.gz">в архиве</a>. Тесты проверяют, что работает

* хоть что-то (пример “Hello, world”)
* рекурсия (факториал, фибоначчи, аккерманн)
* замыкания
* продолжения

Все важные вещи работают. До полной реализации стандарта R5RS остаётся только наделать примитивов. Ах да, совершенно случайно мой псевдокод совпадает с языком <a href="http://www.schemers.org/">Scheme</a> R5RS.

Для своего проекта я использую компилятор Схемы <a href="http://dynamo.iro.umontreal.ca/~gambit/">Gambit</a>. Внутри него — регистрово-стековая виртуальная машина GVM (<a href="http://www.iro.umontreal.ca/~feeley/papers/pvm.ps.gz">A Parallel Virtual Machine for Efficient Scheme Compilation</a>). Вот, во что превращается наш пример, когда оказывается в GVM:

<code><i>; +N: регистр номер N
; -N: ячейка N фрейма стека
; Параметры функций: первый в +1, второй в +2 и т.д.
; Результат функции возвращается в +1
; Используется continuation-passing style, адрес перехода-возврата лежит в +0
; Здесь и далее, escape sequences заменены на русские буквы
;
; Метка #1 плюс всякие полезности</i>
<b>#1</b> 0 entry-point 0 ()
&nbsp;&nbsp;<i>; Глобальная переменная "сделать-писателя" указывает на функцию</i>
&nbsp;&nbsp;|~#сделать-писателя| = '#<procedure |~#сделать-писателя|>
&nbsp;&nbsp;-1 = +0
&nbsp;&nbsp;+1 = '"Привет!\n"
&nbsp;&nbsp;+0 = #3
&nbsp;<i>; Переход на метку #2 плюс всякие полезности</i>
&nbsp;&nbsp;jump* 4 #2
<b>#2</b> 4
&nbsp;&nbsp;<i>; Вызывает функцию. Так как в +0 лежит адрес #3, то туда и вернёмся, а в +1 будет лежать анонимная функция (замыкание)</i>
&nbsp;&nbsp;jump$ 4 |~#сделать-писателя| 1
<b>#3</b> 4 return-point
&nbsp;&nbsp;|~#пиши-привет| = +1
&nbsp;&nbsp;+0 = -1
&nbsp;&nbsp;jump* 4 #4
<b>#4</b> 4
&nbsp;&nbsp;jump$ 0 |~#пиши-привет| 0

**** #<procedure |~#сделать-писателя|> =
<b>#1</b> 0 entry-point 1 ()
&nbsp;&nbsp;<i>; Замыкание -- это функция плюс параметры</i>
&nbsp;&nbsp;close -1 = (#2 +1)
&nbsp;&nbsp;+1 = -1
&nbsp;&nbsp;jump 0 +0
&nbsp;&nbsp;<i>; Начало анонимной функции</i>
<b>#2</b> 0 closure-entry-point 0 ()
&nbsp;&nbsp;<i>; В +4 лежит замыкание, +4(1) -- первый параметр</i>
&nbsp;&nbsp;+1 = +4(1)
&nbsp;&nbsp;jump* 0 #3
<b>#3</b> 0
&nbsp;&nbsp;jump$ 0 display 1
</code>

Результат трансляции GVM на PHP:

<code>
function <b>glo_x20hellowr</b>() {
&nbsp;&nbsp;global $reg0, $reg1, $reg2, $reg3, $reg4, $pc, $fp, $stack, $nargs;
&nbsp;&nbsp;$<b>GLOBALS['glo_сделать-писателя']</b> = 'glo_сделать_писателя';
&nbsp;&nbsp;$<b>stack[$fp+1]</b> = $reg0;
&nbsp;&nbsp;$<b>reg1</b> = "Привет!\n";
&nbsp;&nbsp;$<b>reg0</b> = 'lbl_x20hellowr_3';
&nbsp;&nbsp;$<b>pc</b> = 'lbl_x20hellowr_2';
&nbsp;&nbsp;$<b>fp</b> = $fp+4;
}
function <b>lbl_x20hellowr_2</b>() {
&nbsp;&nbsp;global $reg0, $reg1, $reg2, $reg3, $reg4, $pc, $fp, $stack, $nargs;
&nbsp;&nbsp;$nargs = 1;
&nbsp;&nbsp;$<b>pc</b> = $GLOBALS['glo_сделать-писателя'];
}
function <b>lbl_x20hellowr_3</b>() {
&nbsp;&nbsp;global $reg0, $reg1, $reg2, $reg3, $reg4, $pc, $fp, $stack, $nargs;
&nbsp;&nbsp;$<b>GLOBALS['glo_пиши-привет']</b> = $reg1;
&nbsp;&nbsp;$<b>reg0</b> = $stack[$fp-3];
&nbsp;&nbsp;$<b>pc</b> = 'lbl_x20hellowr_4';
}
function <b>lbl_x20hellowr_4</b>() {
&nbsp;&nbsp;global $reg0, $reg1, $reg2, $reg3, $reg4, $pc, $fp, $stack, $nargs;
&nbsp;&nbsp;$nargs = 0;
&nbsp;&nbsp;$<b>pc</b> = $GLOBALS['glo_пиши-привет'];
&nbsp;&nbsp;$<b>fp</b> = $fp-4;
}
<i>// procedure сделать-писателя =</i>
function <b>glo_сделать_писателя</b>() {
&nbsp;&nbsp;global $reg0, $reg1, $reg2, $reg3, $reg4, $pc, $fp, $stack, $nargs;
&nbsp;&nbsp;$<b>stack[$fp+1]</b> = array('lbl_сделать_писателя_2', $reg1);
&nbsp;&nbsp;$<b>reg1</b> = $stack[$fp+1];
&nbsp;&nbsp;$<b>pc</b> = $reg0;
}
function <b>lbl_сделать_писателя_2</b>() {
&nbsp;&nbsp;global $reg0, $reg1, $reg2, $reg3, $reg4, $pc, $fp, $stack, $nargs;
&nbsp;&nbsp;$<b>reg1</b> = $reg4[1];
&nbsp;&nbsp;$<b>pc</b> = 'lbl_сделать_писателя_3';
}
function <b>lbl_сделать_писателя_3</b>() {
&nbsp;&nbsp;global $reg0, $reg1, $reg2, $reg3, $reg4, $pc, $fp, $stack, $nargs;
&nbsp;&nbsp;$nargs = 1;
&nbsp;&nbsp;$<b>pc</b> = $GLOBALS['glo_display'];
}
exec_scheme_code('<b>glo_x20hellowr</b>');
</code>

<h5>1) Как реализовать goto?</h5>

Каждый блок GVM (от метки до перехода) становится функцией PHP, которая возвращает, куда надо goto. Исполнитель программы "exec_scheme_code($pc)" выглядит примерно так:

$reg0 = 'glo_exit';
while(1) {
&nbsp;&nbsp;$pc = $pc()
}

Вместо компилятора тут получился интерпретатор. Производительность страдает.

Альтернативы?

<h5>2) Superglobals</h5>

В каждой функции приходится перечислять одни и те же глобальные переменные. Может, есть способ сказать PHP, что они глобальные по умолчанию?

<h5>3) Стек</h5>

Вместо аппаратного стека надо использовать программный. Естественно, я взял массив. И немного не угадал. Оказывается, они всегда ассоциативные, с кучей любопытных побочных эффектов, что тоже замедляет работу.

Как сделать быстрый стек?

<h5>4) Производительность</h5>

Естественно, такой PHP-код тормозит. Например, по сравнению с ручной реализацией функции Аккерманна, он в 30 раз медленнее. Я подозреваю, почему (недо-goto и стек), но хочу убедиться.

Какими инструментами мерять, что тормозит?
